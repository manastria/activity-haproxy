---
title: "Partie 3 ‚Äì Configuration HAProxy (TLS frontal + SNI, certificats wildcard vs d√©di√©s)"
description: "Mise en place d'un frontal HAProxy en HTTP puis en HTTPS pour s√©curiser les services."
sidebar:
  order: 2
status: "draft"
level: "BTS SIO 2"
duration: "45 min"
tags: ["haproxy", "tls", "sni", "bts-sio"]
---

import { Aside, Tabs, TabItem, Steps } from '@astrojs/starlight/components';


<Aside type="note" title="Introduction">
Dans cette partie, vous allez mettre en place un **frontal HAProxy** d'abord en HTTP, puis en HTTPS. Vous comparerez un **certificat wildcard** (un seul cert pour plusieurs noms) et **des certificats d√©di√©s** (un par nom).

Chaque √©tape suit un mod√®le simple : **pourquoi ‚Üí comment ‚Üí test ‚Üí √† retenir**.
</Aside>

---

## 1. Pr√©requis techniques

Pour d√©marrer cette activit√©, les pr√©requis des **Parties 1 et 2** doivent √™tre valid√©s.

-   **Routage SNS (pare-feu)** : Le routage entre le **Labo ‚Üî DMZ** est op√©rationnel. Le **NAT sortant** est activ√© c√¥t√© DMZ et le DNS est fonctionnel.
-   **VM HaProxy** : Dispose de 2 interfaces (Labo + DMZ) avec des IPs correctes et peut joindre la DMZ.
-   **VM Backends** : Docker est install√© avec un r√©seau **macvlan**. Les deux conteneurs **`node1` (10.0.0.101)** et **`node2` (10.0.0.102)** sont en cours d'ex√©cution et accessibles depuis la VM HaProxy.

<Aside type="tip" title="Utilisation de cURL">
Sur Windows, lancez `curl` depuis **Git Bash** pour √©viter les alias qui peuvent perturber les exemples.
</Aside>

---

## 2. Objectifs d'apprentissage

√Ä la fin de cette partie, vous serez capable de :
-   Mettre en place un **frontend HTTP** pour valider le routage par **nom d'h√¥te**.
-   Activer **TLS** avec un **certificat wildcard**, en comprenant comment tout nouveau sous-domaine fonctionne sans configuration suppl√©mentaire.
-   Remplacer le certificat wildcard par **deux certificats d√©di√©s** pour comprendre la diff√©rence concr√®te entre les deux approches.
-   Comprendre le principe du **SNI** (*Server Name Indication*) : le client annonce le nom du serveur durant le handshake TLS, permettant √† HAProxy de servir le bon certificat sur le **m√™me port 443**.

---

## 3. √Ä propos des commandes multilignes (`\`)

Plusieurs commandes de ce TP (notamment celles avec `openssl`) sont **trop longues** pour tenir sur une seule ligne. Elles utilisent le caract√®re `\` √† la fin d‚Äôune ligne pour indiquer que la commande **continue sur la ligne suivante**.

<Tabs>
<TabItem label="Exemple de commande multiligne">

```bash
openssl req -x509 -new -nodes -sha256 -days 3650 \
  -key myCA.key \
  -subj "/C=FR/O=TP-HAProxy/OU=Student-CA/CN=My Student Lab CA" \
  -out myCA.crt
````

</TabItem>
<TabItem label="Si cela ne fonctionne pas">

Sur certains claviers ou terminaux, le `\` peut √™tre mal interpr√©t√©. Dans ce cas, **transformez la commande en une seule ligne** :

```bash
openssl req -x509 -new -nodes -sha256 -days 3650 -key myCA.key -subj "/C=FR/O=TP-HAProxy/OU=Student-CA/CN=My Student Lab CA" -out myCA.crt
```

<Aside type="tip" title="Astuce rapide">
Copiez la commande compl√®te dans un √©diteur de texte, puis supprimez les retours √† la ligne. V√©rifiez qu'il ne reste **aucun `\`** et qu'il n'y a **qu'un seul espace** entre chaque option.
</Aside>

</TabItem>
</Tabs>

-----

## 4. Pr√©parer votre Autorit√© de Certification (CA)

### 4.1. Cr√©er la CA (sur la VM HaProxy)

Pour simuler une autorit√© de certification (CA), vous allez g√©n√©rer une cl√© priv√©e et un certificat auto-sign√©.

#### 4.1.1. √âtape 4.1.1 : Cr√©er l'arborescence des fichiers

<Aside type="note" title="Pourquoi ?">
Nous cr√©ons un r√©pertoire d√©di√© (`ca`) pour isoler les fichiers de l'autorit√© de certification. C'est une bonne pratique de s√©curit√© et d'organisation.
</Aside>

```bash
mkdir -p ~/ca
cd ~/ca
```

<details>
<summary>**Explication :**</summary>

  - `mkdir -p ~/ca` cr√©e le dossier `ca` dans votre dossier personnel (`~`). L'option `-p` s'assure que le dossier est cr√©√© m√™me si le parent (`~`) n'existe pas.
  - `cd ~/ca` vous d√©place dans ce nouveau r√©pertoire. Toutes les commandes suivantes seront ex√©cut√©es depuis cet emplacement.
</details>
-----

### 4.2. √âtape 4.1.2 : G√©n√©rer la cl√© priv√©e de la CA

<Aside type="note" title="Pourquoi ?">
Une autorit√© de certification (CA) a besoin d'une **cl√© priv√©e** pour signer les certificats des serveurs. Cette cl√© est le fondement de la confiance. **Gardez-la secr√®te \!**
</Aside>

```bash
openssl genrsa -out myCA.key 4096
```

<details>
<summary>**Explication :**</summary>

  - `openssl genrsa` g√©n√®re une **cl√© priv√©e** au format RSA.
  - `-out myCA.key` enregistre la cl√© dans un fichier nomm√© `myCA.key`.
  - `4096` d√©finit la taille de la cl√© en bits. Une taille de **4096 bits** est plus s√©curis√©e que la taille par d√©faut (2048) et est recommand√©e pour ce type de cl√©.
</details>
-----

### 4.3. √âtape 4.1.3 : G√©n√©rer le certificat de la CA

<Aside type="note" title="Pourquoi ?">
Pour que votre navigateur reconnaisse la validit√© des certificats de vos sites, il doit d'abord faire confiance √† la **CA** qui les a sign√©s. Ce certificat, `myCA.crt`, est la "carte d'identit√©" de votre CA.
</Aside>

```bash
openssl req -x509 -new -nodes -sha256 -days 3650 \
  -key myCA.key \
  -subj "/C=FR/O=TP-HAProxy/OU=Student-CA/CN=My Student Lab CA" \
  -out myCA.crt
```

<details>
<summary>**Explication :**</summary>

  - `openssl req -x509` cr√©e un certificat **auto-sign√©** (`-x509`).
  - `-new` indique de cr√©er une nouvelle demande de signature.
  - `-nodes` d√©sactive le chiffrement de la cl√© priv√©e, √©vitant ainsi d'avoir √† saisir un mot de passe √† chaque utilisation.
  - `-sha256` sp√©cifie l'algorithme de hachage utilis√©.
  - `-days 3650` d√©finit la dur√©e de validit√© du certificat √† **10 ans** (365 jours \* 10).
  - `-key myCA.key` associe ce certificat √† la cl√© priv√©e cr√©√©e pr√©c√©demment.
  - `-subj` permet de renseigner les informations d'identit√© du certificat (Pays, Organisation, Unit√©, Nom Commun). Le `CN` (Common Name) est le nom unique de la CA.
  - `-out myCA.crt` enregistre le certificat dans le fichier `myCA.crt`.
</details>

### 4.4. Installer le certificat `myCA.crt` sur votre poste

Pour que votre navigateur reconnaisse les certificats sign√©s par votre CA, vous devez l'installer dans le magasin de certificats de votre syst√®me.

  - **Windows** : double-clic sur le fichier `myCA.crt` ‚Üí *Ordinateur local* ‚Üí **Autorit√©s de certification racines de confiance**.
  - **macOS** : Trousseaux d'acc√®s ‚Üí *Syst√®me* ‚Üí importer le fichier ‚Üí ¬´ Toujours approuver ¬ª.
  - **Linux** :
    ```bash
    sudo cp myCA.crt /usr/local/share/ca-certificates/
    sudo update-ca-certificates
    ```

### 4.5. V√©rifier la CA sur la VM HaProxy

```bash
ls -lh ~/ca/myCA.crt ~/ca/myCA.key
openssl x509 -in ~/ca/myCA.crt -noout -subject -issuer -enddate
```

**Comprendre les r√©sultats :**

  - La premi√®re commande v√©rifie l'existence des fichiers de la cl√© priv√©e (`myCA.key`) et du certificat public (`myCA.crt`).
  - La seconde commande affiche les m√©tadonn√©es du certificat. Le `subject` et l'`issuer` sont identiques, ce qui confirme que c'est un **certificat auto-sign√©**.

‚úÖ Si ces deux v√©rifications sont correctes, votre CA est fonctionnelle.

-----

## 5. 5\. Installer et tester HAProxy

```bash
sudo apt update
sudo apt install -y haproxy
```

**V√©rifiez l'installation :**

```bash
haproxy -v
```

Le programme doit afficher la version install√©e. Si `command not found` s'affiche, l'installation a √©chou√©.

-----

## 6. 6\. Phase A ‚Äî Frontend HTTP : premiers tests de routage

<Aside type="note" title="Objectif">
V√©rifiez que HAProxy est capable de **recevoir des requ√™tes HTTP** et de les **rediriger vers le bon serveur backend** (`node1` ou `node2`).
</Aside>

### 6.1. Comprendre le r√¥le de HAProxy

HAProxy est un **reverse proxy** qui agit comme un interm√©diaire entre le client et les serveurs web (*backends*).

| √âl√©ment | R√¥le |
| :--- | :--- |
| **Frontend** | Le **point d'entr√©e** qui √©coute sur un port (ex: 80 ou 443). |
| **Backend** | Le **groupe de serveurs** vers lequel le trafic est redirig√©. |
| **ACL** (*Access Control List*) | Permet √† HAProxy de prendre des d√©cisions de routage dynamiques (ex: en fonction du nom d'h√¥te). |

### 6.2. Configuration principale

Le fichier de configuration principal est `/etc/haproxy/haproxy.cfg`. Faites-en d'abord une sauvegarde.

```bash
sudo cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak
```

Ensuite, remplacez le contenu par la configuration minimale ci-dessous :

```bash
sudo nano /etc/haproxy/haproxy.cfg
```

```ini
# Configuration de base (timeouts et logs)
defaults
  mode http
  option httplog
  timeout connect 5s
  timeout client 30s
  timeout server 30s

# FRONTEND : point d'entr√©e des requ√™tes
frontend fe_http
  bind :80
  # R√®gles selon le nom demand√© dans l'en-t√™te "Host"
  acl host_node1 hdr(host) -i node1.example.test
  acl host_node2 hdr(host) -i node2.example.test

  # S√©lection du backend correspondant
  use_backend be_node1 if host_node1
  use_backend be_node2 if host_node2

  # Filet de s√©curit√©
  default_backend be_node1

# BACKENDS : serveurs internes (dans la DMZ)
backend be_node1
  server n1 10.0.0.101:80 check

backend be_node2
  server n2 10.0.0.102:80 check
```

### 6.3. D√©marrer HAProxy

**1. Valider la syntaxe :**

```bash
sudo haproxy -c -f /etc/haproxy/haproxy.cfg
```

Vous devez voir `Configuration file is valid`.

**2. D√©marrer le service :**

```bash
sudo systemctl restart haproxy
sudo systemctl status haproxy
```

L'√©tat doit √™tre `active (running)`.

### 6.4. Tester le routage HTTP

<Tabs>
<TabItem label="Cas 1 ‚Äî Sans DNS (recommand√©)">

Ici, on simule le nom du site avec l'en-t√™te `Host:` de `curl`.

```bash
curl -H "Host: node1.example.test" [http://172.25.](http://172.25.)X.2/
curl -H "Host: node2.example.test" [http://172.25.](http://172.25.)X.2/
```

</TabItem>
<TabItem label="Cas 2 ‚Äî Avec r√©solution DNS locale">

Si vous avez d√©j√† ajout√© les noms dans votre fichier `/etc/hosts` ou votre DNS :

```
# /etc/hosts
172.25.X.2  node1.example.test
172.25.X.2  node2.example.test
```

Alors vous pouvez tester directement :

```bash
curl [http://node1.example.test](http://node1.example.test)
curl [http://node2.example.test](http://node2.example.test)
```

</TabItem>
</Tabs>

### 6.5. Comprendre les r√©sultats

Si la configuration est correcte, vous devez voir **deux contenus diff√©rents**, car chaque conteneur (`node1`/`node2`) affiche une page unique.

  - **Si vous voyez toujours la m√™me page :** il y a une erreur dans la configuration des ACLs ou du fichier `haproxy.cfg`.
  - **Si aucune r√©ponse :** v√©rifiez si le service HAProxy est bien actif (`sudo systemctl status haproxy`) et si les backends sont accessibles.

<Aside type="tip" title="Lien avec le SNI">
En HTTP, le nom (`Host:`) est envoy√© **apr√®s la connexion TCP**. En HTTPS, ce m√™me nom doit √™tre annonc√© plus t√¥t, durant le handshake TLS. C'est le r√¥le du **SNI**, que vous testerez dans la phase suivante.
</Aside>

### 6.6. ‚úÖ Validation avant de poursuivre

V√©rifiez que les points suivants sont valid√©s avant de passer √† la phase B.


  - [ ] `curl -H "Host: node1.example.test" http://172.25.X.2` renvoie un contenu valide.
  - [ ] `curl -H "Host: node2.example.test" http://172.25.X.2` renvoie un contenu diff√©rent.
  - [ ] `sudo haproxy -c -f /etc/haproxy/haproxy.cfg` renvoie `Configuration file is valid`.

-----

## 7. 7\. Phase B ‚Äî TLS avec **certificat wildcard**

<Aside type="note" title="Objectif">
√âmettre et configurer un certificat wildcard (`*.example.test`) sur HAProxy pour s√©curiser plusieurs sous-domaines avec un seul certificat.
</Aside>

### 7.1. Qu'est-ce qu'un certificat wildcard ?

Un **certificat wildcard** est un certificat TLS/SSL qui couvre **plusieurs sous-domaines** d'un m√™me domaine principal en utilisant un ast√©risque (`*.example.test`).

| Avantages | Inconv√©nients |
| :--- | :--- |
| ‚úÖ **Simplicit√©** : Un seul certificat √† g√©rer. | ‚ùå **S√©curit√©** : Si la cl√© fuit, tous les sous-domaines sont compromis. |
| ‚úÖ **Flexibilit√©** : Ajout instantan√© de nouveaux sous-domaines. | ‚ùå **Granularit√© limit√©e** : On ne peut pas r√©voquer un seul sous-domaine. |

### 7.2. √âmettre le certificat wildcard

Le processus se d√©roule en trois √©tapes :

1.  **G√©n√©rer** la cl√© priv√©e et la demande de signature (CSR).
2.  **D√©finir** les extensions SAN.
3.  **Signer** le tout avec votre CA.

<Steps>

1. G√©n√©rer la cl√© et la CSR

    ```bash
    cd ~/ca

    openssl req -new -newkey rsa:2048 -nodes \
    -keyout wildcard-example-test.key \
    -subj "/CN=*.example.test" \
    -out wildcard-example-test.csr
    ```

2. Cr√©er le fichier d‚Äôextensions SAN

    <Aside type="note" title="Le r√¥le des SAN">
    Les navigateurs modernes ne v√©rifient plus le *Common Name* (CN), mais uniquement la liste de **SAN** (*Subject Alternative Name*). Un certificat sans SAN ne fonctionnera pas correctement.
    </Aside>

    ```bash
    cat > san-wildcard.cnf <<'EOF'
    subjectAltName=DNS:*.example.test,DNS:example.test
    EOF
    ```

3. Signer la demande avec la CA

    ```bash
    openssl x509 -req -in wildcard-example-test.csr \
    -CA myCA.crt -CAkey myCA.key -CAcreateserial \
    -out wildcard-example-test.crt -days 365 -sha256 \
    -extfile san-wildcard.cnf
    ```
</Steps>

‚úÖ Vous devriez maintenant avoir les fichiers `wildcard-example-test.key` et `wildcard-example-test.crt`.

### 7.3. √âtape 7.3 : Pr√©parer le fichier PEM pour HAProxy

HAProxy attend un fichier unique au format **PEM** (*Privacy Enhanced Mail*) qui regroupe le **certificat public**, la **cl√© priv√©e** et le **certificat de la CA**.

#### 7.3.1. Cr√©er le r√©pertoire de destination

<Aside type="note" title="Pourquoi ?">
Pour une bonne organisation et pour respecter les standards des services syst√®me, nous allons stocker les certificats d'HAProxy dans un r√©pertoire d√©di√©, s√©curis√© et bien connu : `/etc/haproxy/certs`.
</Aside>

```bash
sudo mkdir -p /etc/haproxy/certs
```

<details>
<summary>**Explication :**</summary>

  - `sudo mkdir -p` cr√©e le r√©pertoire `/etc/haproxy/certs` avec des privil√®ges d'administrateur.
  - L'option `-p` est utilis√©e pour cr√©er les r√©pertoires parents s'ils n'existent pas d√©j√†.
</details>

#### 7.3.2. Assembler le certificat en un fichier PEM

<Aside type="note" title="Pourquoi ?">
HAProxy a besoin d'un seul fichier qui contient tout pour un certificat donn√© : le certificat (`.crt`), la cl√© priv√©e (`.key`) et le certificat de la CA (`myCA.crt`) pour la cha√Æne de confiance.
</Aside>

```bash
cat wildcard-example-test.crt wildcard-example-test.key myCA.crt \
  | sudo tee /etc/haproxy/certs/wildcard-example-test.pem >/dev/null
```

<details>
<summary>**Explication :**</summary>

  - `cat` concat√®ne (combine) le contenu des trois fichiers (`.crt`, `.key`, `myCA.crt`) dans l'ordre requis.
  - Le caract√®re `|` (pipe) envoie la sortie de la commande `cat` en entr√©e de la commande `sudo tee`.
  - `tee` √©crit le flux d'entr√©e dans un fichier, ici `/etc/haproxy/certs/wildcard-example-test.pem`, avec des privil√®ges `sudo`.
  - `>/dev/null` permet de supprimer la sortie standard de la commande `tee` qui, sinon, afficherait le contenu du fichier dans le terminal.
</details>

#### 7.3.3. Ajuster les droits d'acc√®s

<Aside type="note" title="Pourquoi ?">
Le fichier PEM contient la **cl√© priv√©e**, qui doit √™tre prot√©g√©e. Nous ajustons les permissions pour que seul l'utilisateur et le groupe `haproxy` puissent y acc√©der.
</Aside>

```bash
sudo chown haproxy:haproxy /etc/haproxy/certs/wildcard-example-test.pem
sudo chmod 640 /etc/haproxy/certs/wildcard-example-test.pem
```

<details>
<summary>**Explication :**</summary>

  - `chown haproxy:haproxy` change le propri√©taire et le groupe du fichier en `haproxy`. Cela est n√©cessaire pour que le service HAProxy puisse lire le fichier.
  - `chmod 640` d√©finit les permissions :
      - Le **propri√©taire** (`haproxy`) peut lire et √©crire (6).
      - Le **groupe** (`haproxy`) peut seulement lire (4).
      - Les **autres** utilisateurs n'ont aucune permission (0).
</details>

### 7.4. Activer HTTPS dans HAProxy

<Aside type="note" title="Du HTTP au HTTPS">
Maintenant que votre certificat est pr√™t, vous allez modifier la configuration d'HAProxy pour passer du protocole **HTTP** au protocole **HTTPS**. HAProxy agira comme un **terminateur TLS** : il va d√©chiffrer les communications des clients (en HTTPS) avant de les rediriger en interne vers les backends (qui, eux, resteront en HTTP).

Vous allez aussi mettre en place une redirection automatique pour que toute tentative de connexion en HTTP soit automatiquement transform√©e en une connexion s√©curis√©e en HTTPS.

</Aside>

-----


Modifiez le fichier `/etc/haproxy/haproxy.cfg` avec le nouveau frontend :

```ini
frontend fe_https
  # Redirection HTTP -> HTTPS
  bind :80
  http-request redirect scheme https unless { ssl_fc }

  # Frontend HTTPS avec le certificat wildcard
  bind :443 ssl crt /etc/haproxy/certs/wildcard-example-test.pem

  # R√®gles et backends restent identiques
  acl host_node1 hdr(host) -i node1.example.test
  acl host_node2 hdr(host) -i node2.example.test
  use_backend be_node1 if host_node1
  use_backend be_node2 if host_node2
  default_backend be_node1

# Les BACKENDS restent inchang√©s
backend be_node1
  server n1 10.0.0.101:80 check

backend be_node2
  server n2 10.0.0.102:80 check
```

**V√©rifiez la syntaxe et red√©marrez le service :**

```bash
sudo haproxy -c -f /etc/haproxy/haproxy.cfg
sudo systemctl restart haproxy
sudo systemctl status haproxy
```

### 7.5. Tester en ligne de commande et navigateur

<Aside type="note" title="L'importance de la v√©rification">
Une configuration, aussi simple soit-elle, doit toujours √™tre test√©e. Dans cette section, vous allez v√©rifier si HAProxy sert bien le certificat que vous venez de g√©n√©rer. Vous utiliserez d'abord des outils en ligne de commande comme `openssl` et `curl` pour valider les aspects techniques, puis vous testerez le tout avec un navigateur pour vous assurer que l'exp√©rience utilisateur est correcte (le fameux cadenas !).
</Aside>


#### 7.5.1. Inspecter le certificat avec `openssl`

Cette commande permet de v√©rifier le certificat servi par HAProxy en incluant le SNI.

```bash
openssl s_client -connect 172.25.X.2:443 -servername node1.example.test < /dev/null \
 | openssl x509 -noout -subject -issuer
# Attendu : subject=CN=*.example.test | issuer=My Student Lab CA
```

#### 7.5.2. Tester un nouveau sous-domaine

Ajoutez une entr√©e √† votre fichier `/etc/hosts` pour simuler le routage DNS, puis testez-le avec `curl`.

<Aside type="tip" title="Comprendre --resolve">
En HTTPS, le **SNI** doit correspondre au nom demand√©. L'option `--resolve` de `curl` simule une entr√©e DNS temporaire, ce qui garantit que le SNI et le `Host` sont coh√©rents.
</Aside>

```bash
# Ajout au fichier hosts pour le test
echo "172.25.X.2  newsite.example.test" | sudo tee -a /etc/hosts
# Test du nouveau sous-domaine avec curl
curl -I [https://newsite.example.test](https://newsite.example.test)
# Attendu : 200/301/302 SANS erreur de certificat (pas de -k)
```

#### 7.5.3. Tester avec votre navigateur

1.  Ajoutez les entr√©es DNS dans le fichier `/etc/hosts` de votre **poste h√¥te** (et non la VM) :
    ```
    172.25.X.2  node1.example.test
    172.25.X.2  node2.example.test
    172.25.X.2  newsite.example.test
    ```
2.  Acc√©dez √† [**https://node1.example.test/**](https://www.google.com/search?q=https://node1.example.test/), [**https://node2.example.test/**](https://www.google.com/search?q=https://node2.example.test/) et [**https://newsite.example.test/**](https://www.google.com/search?q=https://newsite.example.test/).
3.  V√©rifiez que le cadenas est **ferm√©** et qu'aucune alerte de s√©curit√© n'appara√Æt.

### 7.6. ‚úÖ Validation

  - [ ] `openssl s_client` renvoie **`CN=*.example.test`** et `Issuer=My Student Lab CA`.
  - [ ] `curl` sur un nouveau sous-domaine (`newsite.example.test`) fonctionne **sans erreur de certificat**.
  - [ ] Le navigateur affiche un **cadenas vert**, et le certificat pr√©sente un **Subject CN=\*.example.test** et un **SAN** correct.

-----

## 8. Phase C ‚Äî TLS avec **certificats d√©di√©s**

<Aside type="note" title="Objectif">
Comprendre la logique du SNI en rempla√ßant le certificat wildcard par **deux certificats ind√©pendants** (un pour `node1` et un pour `node2`).
</Aside>

### 8.1. G√©n√©rer les certificats d√©di√©s

Pour chaque site, vous allez suivre les trois √©tapes habituelles : cl√© priv√©e, CSR, puis signature.

<Steps>
1. Cr√©er les cl√©s et les CSRs

    ```bash
    cd ~/ca
    # node1
    openssl req -new -newkey rsa:2048 -nodes \
    -keyout node1.key \
    -subj "/CN=node1.example.test" \
    -out node1.csr

    # node2
    openssl req -new -newkey rsa:2048 -nodes \
    -keyout node2.key \
    -subj "/CN=node2.example.test" \
    -out node2.csr
    ```

2. Ajouter les extensions SAN

    ```bash
    echo "subjectAltName=DNS:node1.example.test" > san-node1.cnf
    echo "subjectAltName=DNS:node2.example.test" > san-node2.cnf
    ```

3. Signer les CSRs avec la CA

    ```bash
    # node1
    openssl x509 -req -in node1.csr -CA myCA.crt -CAkey myCA.key -CAcreateserial \
    -out node1.crt -days 365 -sha256 -extfile san-node1.cnf

    # node2
    openssl x509 -req -in node2.csr -CA myCA.crt -CAkey myCA.key -CAcreateserial \
    -out node2.crt -days 365 -sha256 -extfile san-node2.cnf
    ```
</Steps>

‚úÖ Vous devriez maintenant avoir deux paires de fichiers : `node1.key`/`node1.crt` et `node2.key`/`node2.crt`.

### 8.2. Pr√©parer les fichiers PEM et configurer HAProxy

Supprimez l'ancien certificat et cr√©ez les deux nouveaux fichiers PEM pour HAProxy.

```bash
# Supprimer les anciens certificats
rm /etc/haproxy/certs/*

# Cr√©er les nouveaux PEM
cat node1.crt node1.key myCA.crt | sudo tee /etc/haproxy/certs/node1.pem >/dev/null
cat node2.crt node2.key myCA.crt | sudo tee /etc/haproxy/certs/node2.pem >/dev/null

sudo chown haproxy:haproxy /etc/haproxy/certs/*.pem
sudo chmod 640 /etc/haproxy/certs/*.pem
```

Modifiez le fichier `haproxy.cfg` en listant les deux certificats d√©di√©s dans la directive `bind`.

```ini
frontend fe_https
  bind :80
  http-request redirect scheme https unless { ssl_fc }

  # Liste des certificats d√©di√©s
  bind :443 ssl crt /etc/haproxy/certs/node1.pem crt /etc/haproxy/certs/node2.pem

  acl host_node1 hdr(host) -i node1.example.test
  acl host_node2 hdr(host) -i node2.example.test
  use_backend be_node1 if host_node1
  use_backend be_node2 if host_node2
  default_backend be_node1

# Backends inchang√©s
backend be_node1
  server n1 10.0.0.101:80 check
backend be_node2
  server n2 10.0.0.102:80 check
```

### 8.3. Tester et comprendre

#### 8.3.1. Test avec `openssl`

V√©rifiez que HAProxy sert le bon certificat pour chaque nom de domaine.

```bash
openssl s_client -connect 172.25.X.2:443 -servername node1.example.test < /dev/null \
 | openssl x509 -noout -subject -issuer
# Attendu : subject=CN=node1.example.test
# Attendu : issuer=My Student Lab CA
```

R√©p√©tez la commande pour `node2.example.test` pour v√©rifier son propre certificat.

#### 8.3.2. Test d'un nom non couvert

V√©rifiez maintenant qu'un sous-domaine non list√© provoque une erreur.

```bash
curl --resolve newsite.example.test:443:172.25.X.2 [https://newsite.example.test](https://newsite.example.test)
```

La commande doit **√©chouer** car le certificat n'est plus valide pour ce nom.

#### 8.3.3. Test avec votre navigateur

  - Ajoutez les entr√©es pour `node1` et `node2` dans `/etc/hosts` de votre poste.
  - Acc√©dez √† [**https://node1.example.test/**](https://www.google.com/search?q=https://node1.example.test/) et [**https://node2.example.test/**](https://www.google.com/search?q=https://node2.example.test/).
  - V√©rifiez que le **cadenas est vert** et que le certificat correspond bien au site affich√©.

### 8.4. Comparaison finale : Wildcard vs Multi-certs

| Wildcard (`*.example.test`) | Multi-certs (`node1.example.test`, `node2.example.test`) |
| :--- | :--- |
| ‚úÖ Simple √† g√©rer (1 seul fichier) | üîí Plus s√ªr (compartimentation) |
| ‚ö†Ô∏è Si la cl√© fuit, tous les sous-domaines sont compromis | ‚ö†Ô∏è Plus de certificats √† maintenir |
| üåê Les nouveaux sous-domaines fonctionnent automatiquement | üö´ Un nouveau nom n√©cessite un nouveau certificat |
| üí° Id√©al pour les labs et les environnements de dev | üíº Recommand√© en production |

-----

<details class="foldable">
<summary><h2>9. D√©pannage express</h2></summary>

  - **Alertes TLS** : N'ignorez pas. Assurez-vous que votre **CA est install√©e** sur le poste et que le **fichier PEM est complet** (`certificat + cl√© + CA`).
  - **HTTP OK / HTTPS KO** : V√©rifiez la directive `bind :443 ssl crt ...`, les **droits d'acc√®s** (`chmod 640`), et la validit√© des **SAN**.
  - **`curl` Windows** : Utilisez **Git Bash** et pr√©f√©rez `--resolve` pour les tests en HTTPS.

</details>

-----

## 9. Auto-√©valuation

  - [ ] **Pass A** : Contenus diff√©rents en HTTP selon l'en-t√™te `Host`.
  - [ ] **Pass B** : Certificat `CN=*.example.test` et le site `newsite.example.test` **fonctionne**.
  - [ ] **Pass C** : Certificats d√©di√©s (`CN=node1.example.test` et `CN=node2.example.test`), et le site `newsite.example.test` **√©choue**.

‚úÖ Si vous avez valid√© les trois sections, vous avez acquis une solide compr√©hension du routage HAProxy et du r√¥le du SNI.
